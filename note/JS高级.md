---

---

### 一、闭包

1.闭包指的是：能够访问另一个函数作用域的变量的函数

2.闭包的三个特性：

- 函数嵌套函数
- 函数内部可以引用函数外部的参数和变量
- 参数和变量不会被垃圾回收机制回收

3.典型的闭包

~~~js
for(let i=0;i<5;i++){
    ((i)=>{
        setTimeout(()=>{
            console.log(i)
        },1000)
    })(i)
}
//0,1,2,3,4
~~~

4.闭包的好处

- 保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突
- 在内存中维持一个变量，可以做缓存（但使用多了会消耗内存）
- 匿名自执行函数可以减少内存消耗

5.闭包的坏处

- 被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用变量后手动为它赋值为null
- 由于闭包涉及跨域访问，所以会导致性能损失，可以通过把跨域作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

### 二、堆内存、栈内存

1. 栈内存：用来存放值类型（基本数据类型）：string、number、boolean、null、undefined
2. 堆内存：用来存放javascript的数据和方法(引用类型)：function、object、array

### 三、函数的参数

1. 形参：函数定义的参数
2. 实参：函数调用时实际传递的参数

### 四、事件循环机制（Event Loop）

1. javascript是单线程的
2. 浏览器：
   - JavaScript执行线程：负责执行js代码
   - UI线程：负责UI展示，负责展示给用户看到的界面
   - javascript事件循环机制
3. JavaScript执行线程和UI线程是互斥的。
4. JavaScript中的任务分为同步任务和异步任务
   - 同步任务：一般的赋值操作、循环、分支语句等
   - 异步任务：DOM事件、Ajax、BOM的一些API等
5. 事件循环机制
   - javascript的执行引擎的主线程，从任务队列中获取任务执行
   - 如果任务是异步任务，那么运行到异步任务时，异步任务就退出主线程，主线程进行下一个任务的获取处理
   - 如果异步任务完成，就插入到任务队列的末尾，等待主线程处理。

### 五、函数执行上下文（ExcutionContext）

1. 栈的数据结构：先进后出

2. 执行上下文的生命周期

   - 创建(生成变量对象、建立作用域链、确定this指向) --->执行(变量赋值、函数引用、执行其他代码) ----执行完毕后出栈，等待被回收
   - 创建阶段：
     - 创建作用域链(Scope Chain)
     - 创建变量对象(或者AO)：首先初始化函数的参数arguments，初始化函数声明，初始化变量(undefined)。函数的优先级要高于变量，若两者同名，变量会被覆盖。
       - 创建arguments对象，检查上下文，初始化参数名称和值并创建引用的复制
       - 扫描上下文的函数声明(而非函数表达式)
         - 为发现的每一个函数，在变量对象上创建一个属性---确切地说是函数的名字--其有一个指向函数在内存中的引用。
         - 如果函数的名字已经存在，引用指针将被重写。
       - 扫描上下文的变量声明
         - 为发现的每个变量声明。在变量对象上创建一个属性---就是变量的名字，并且将变量的值初始化为undefined
         - 如果变量的名字已经在变量对象里存在，将不会进行任何操作并继续扫描
       - 求出上下文内部“this”的值
   - 执行阶段
     - JavaScript的执行分为解释和执行两个阶段
     - 解释阶段：词法分析、语法分析、作用域规则确定
     - 执行阶段：创建执行上下文、执行函数代码、垃圾回收

3. 函数变量的作用域

   ①作用域：就是变量声明的区域，就是变量和函数可访问的范围

### 六、变量提升(hositing)

1. 变量声明在函数体内，其作用域为函数内部；在全局环境下声明，作用域为全局。通过var声明的变量无法用delete删除。
2. 函数内部声明的变量会被提升到函数的头部。函数在解析执行的时候，先进行变量声明处理，然后再运行函数内部的代码。
3. 变量和赋值语句一起书写，在js引擎解析时，会将其拆成声明和赋值两部分，声明置顶，赋值保留在原来的位置。
4. 变量重复声明不会出错，后面的会覆盖前面的。

### 七、作用域链

1. 作用域链是一个数组
2. 作用域链是控制变量作用域的有序访问的js内部实现
3. 作用域链存储在函数的执行上下文中，作用域链中存放的是执行环境中的vo或者ao
4. 当前函数的作用域对象都是在最前端，而且全局的在最末端

### 八、函数调用模式和this

1. 方法调用模式
   - 如果一个函数作为对象的一个方法属性调用，那么它的调用模式就是方法调用模式。
   - var a={}；a.toString( )；//方法调用
   - 方法调用模式的this指向调用对象
2. 函数调用模式
   - 如果一个函数被直接调用，name调用者其实就是全局对象：window
   - 函数调用模式中的this指向全局对象
   - function fn();  fn() //函数调用模式
3. 构造器调用模式
   - 构造器调用模式就是构造函数调用。
   - 构造器模式调用必须有关键字new。
   -   构造器模式调用的this指向创建出来的新对象。
   - var t =new Dog()
4. apply/call调用模式（借用方法模式）
   - apply和call可以改变函数调用的内部this指向。
   - apply和call的功能一样，只不多参数不一样，第一个参数都是改变函数内部this的指向。
   - 第一个参数如果是null、undefined会被全局对象取代，如果是简单类型会被包装类型替代。
   - call的第二个参数开始后面的都是传给函数的参数，可以有多个，用逗号隔开。
   - apply第二个参数是一个传给函数的参数数组。
   - 调用：function m(a){}; m.call(window,2); m.apply(window, [2]);

### 九、函数重载

1. 重载的概念：在程序中。可以定义相同名字，不同参数的形式的不同函数。函数在调用的时候，自动识别不同参数对应的函数，实现了相同函数名不同的函数调用
2. javascript中函数不能重名，如果重名后面的会把前面的覆盖，这是因为所有的函数声明都会创建在vo或者ao的一个属性，而后面声明的函数会把前面的vo或者ao中的同名属性覆盖。
3. javascript中可以通过arguments实现函数重载。
4. 数组slice、splice方法等都可以传入一个或多个参数不同参数内部实现方法不一样，就是方法重载。

### 十、函数的递归调用

1. 函数的递归调用就是指：函数调用自身
2. 、arguments.callee就是指向函数自身的变量，所以可以直接用它来代替函数名，在匿名函数中非常有用。但是在严格模式下会报错。

### 十一、函数式编程

1. 函数是JavaScript的一等公民。
2. 所谓“第一等公民”，指的是函数与其他数据类型一样处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

### 十二、垃圾回收

1. JavaScript具有自动垃圾回收机制(GC:Garbage Collection)。我们不用关心变量的申请和回收。
2. 垃圾收集器会定期(周期性)找出那些不再继续使用变量，然后释放其内存。
3. JavaScript最常用的垃圾回收机制就是标记清除。
4. 垃圾回收的应用
   - 数组的清零操作：最好是通过arr.length=0实现数组清零。arr=[ ]虽然能清零，但会创建一个新的空数组对象，开辟新的内存。
   - 对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用，不用的对象尽可能设置为null，尽快回收。
   - 在循环中的函数表达式，能复用最好放到循环外面。